import: zeromq("net/zeromq")
import: json("fmt/json")
import: glib("gir/GLib")
import: gtk("gir/Gtk@3.0")
import: hmac("digest/hmac")
import: base16("enc/base16")
import: time("std/time")

let Config := with Json := file(sys::Args[1], "r") do
	must Json:close
	json::decode(Json:rest)
end

print('\n\nConfig = {Config}\n')

let Key := Config["key"]
let Session := string(std::uuid())

print('Starting session = {Session}\n')

let Heartbeat := zeromq::socket(zeromq::socket::type::Rep)
Heartbeat:bind('{Config["transport"]}://{Config["ip"]}:{Config["hb_port"]}')

let Shell := zeromq::socket(zeromq::socket::type::Router)
Shell:bind('{Config["transport"]}://{Config["ip"]}:{Config["shell_port"]}')

let Control := zeromq::socket(zeromq::socket::type::Router)
Control:bind('{Config["transport"]}://{Config["ip"]}:{Config["control_port"]}')

let Stdin := zeromq::socket(zeromq::socket::type::Router)
Stdin:bind('{Config["transport"]}://{Config["ip"]}:{Config["stdin_port"]}')

let IOPub := zeromq::socket(zeromq::socket::type::Pub)
IOPub:bind('{Config["transport"]}://{Config["ip"]}:{Config["iopub_port"]}')

fun listen(Name, Socket, Callback) do
	glib::unix_fd_add_full(0, Socket:fd, glib::IOCondition::in; Fd, Condition) do
		if Socket:events /\ 1 = 1 then
			let Message := list(zeromq::message(Socket), :data)
			print('{Name} <- {Message}\n')
			let Ids := with Index := Message:find("<IDS|MSG>") do
				Message:splice(1, Index)
			end
			let Signature := Message:pop
			let Header := json::decode(Message:pop)
			let Parent := json::decode(Message:pop)
			let Metadata := json::decode(Message:pop)
			let Content := json::decode(Message:pop)
			Callback(Ids, Signature, Header, Parent, Metadata, Content)
		end
		ret true
	on Error do
		print('Error: {Error:type}: {Error:message}\n{Error:trace}\n')
		ret true
	end
end

fun send(Name, Socket, Ids, MsgType, Parent, Metadata, Content, [Extra]) do
	let MsgId := string(std::uuid())
	let HeaderJson := json::encode({
		"msg_id" is MsgId,
		"username" is "kernel",
		"session" is Session,
		"msg_type" is MsgType,
		"version" is "5.3",
		"date" is string(time(), nil)[1, 27] + "Z"
	})
	let ParentJson := json::encode(Parent)
	let MetadataJson := json::encode(Metadata)
	let ContentJson := json::encode(Content)
	let HMAC := hmac::sha256(Key)
	HMAC:update(HeaderJson)
	HMAC:update(ParentJson)
	HMAC:update(MetadataJson)
	HMAC:update(ContentJson)
	let Signature := base16::encode(HMAC:digest):lower
	let Message := list(Ids):put(Signature, HeaderJson, ParentJson, MetadataJson, ContentJson):grow(Extra)
	print('{Name} -> {Message}\n')
	zeromq::message(Message):send(Socket)
	ret MsgId
end

listen("Heartbeat", Heartbeat; Message) do
end

listen("Shell", Shell; Ids, Signature, Header, Parent, Metadata, Content) do
	switch Header["msg_type"]: string
	case "kernel_info_request" do
		send("Shell", Shell, Ids, "kernel_info_reply", Header, {}, {
			"status" is "ok",
			"protocol_version" is "5.3.0",
			"implementation" is "minilang",
			"implementation_version" is "0.0.1",
			"language_info" is {
				"name" is "minilang",
				"version" is "0.0.1",
				"mimetype" is "text/x-minilang",
				"file_extension" is ".mini"
			},
			"banner" is "Minilang in Jupyter :)"
		});
	else
		print('Unknown message type = {Header["msg_type"]}\n')
	end
end

listen("Control", Control; Ids, Signature, Header, Parent, Metadata, Content) do
	switch Header["msg_type"]: string
	case "kernel_info_request" do
		send("Control", Control, Ids, "kernel_info_reply", Header, {}, {
			"status" is "ok",
			"protocol_version" is "5.3",
			"implementation" is "minilang",
			"implementation_version" is "0.0.1",
			"language_info" is {
				"name" is "minilang",
				"version" is "0.0.1",
				"mimetype" is "text/x-minilang",
				"file_extension" is ".mini"
			},
			"banner" is "Minilang in Jupyter :)"
		});
	else
		print('Unknown message type = {Header["msg_type"]}\n')
	end
end

listen("Stdin", Stdin; Message) do
end

